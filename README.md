# Algorithm-Complexity-Analysis

<h1 align="center">Algorithm Complexity Analysis</h1>
<h3 align="center">A University Project by TrivialTarzan</h3>

<h4 align="left">In this project, I measured the runtime of various algorithms using C++ and visualized the results using Python and Matplotlib. The algorithms analyzed include:</h4>

<ul>
  <li>Insertion Sort</li>
  <li>Selection Sort</li>
  <li>Jump Search</li>
  <li>Binary Search (Recursive)</li>
  <li>Binary Search (Iterative)</li>
  <li>Linear Search</li>
  <li>Cocktail Sort</li>
  <li>Bubble Sort</li>
</ul>

<h4 align="left">The results of the analysis are showcased in tables and graphs. The raw data for each algorithm is available in text files, allowing you to explore the performance of each algorithm in detail.</h4>

### Technologies Used

- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/cplusplus/cplusplus-original.svg" alt="cplusplus" width="40" height="40"/> C++
- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/python/python-original.svg" alt="python" width="40" height="40"/> Python
- <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/matplotlib/matplotlib-original.svg" alt="matplotlib" width="40" height="40"/> Matplotlib

### Project Overview

The goal of this project was to analyze and compare the runtime performance of different algorithms. I implemented the algorithms in C++ and measured their execution time on various input sizes. To visualize the results, I used Python and the Matplotlib library to create graphs that display the time complexity of each algorithm.

#### Algorithms Tested:
- **Insertion Sort**: A simple sorting algorithm that builds the sorted array one item at a time.
- **Selection Sort**: An algorithm that repeatedly selects the smallest element from the unsorted part of the list.
- **Jump Search**: An algorithm that searches for an element in a sorted list by jumping ahead by a fixed number of steps.
- **Binary Search (Recursive)**: A recursive algorithm to find an element in a sorted list by repeatedly dividing the search range in half.
- **Binary Search (Iterative)**: A non-recursive version of Binary Search that also halves the search range iteratively.
- **Linear Search**: A simple algorithm that checks each element in a list one by one.
- **Cocktail Sort**: A variation of Bubble Sort that moves in both directions through the list.
- **Bubble Sort**: A simple sorting algorithm that repeatedly steps through the list, compares adjacent items, and swaps them if they are in the wrong order.

### Results

The results are provided in two forms:
1. **Tables**: These show the raw runtime data for each algorithm tested.
2. **Graphs**: These visualizations were created using Python and Matplotlib, offering a clear comparison of algorithm performances based on the input size.

### Files Included

- `algorithm_results/`: Contains text files with the raw data for each algorithm's execution time.
- `graphs/`: Contains the visualizations generated using Matplotlib.

### How to Run

1. Clone this repository:
   ```bash
   git clone https://github.com/yourusername/Algorithm-Complexity-Analysis.git


This project is open-source and available under the MIT License.

Acknowledgments

This project was developed as part of a university research initiative focused on analyzing the time complexity of fundamental algorithms. Special thanks to faculty mentors for their guidance.
